//
//  ApplicationSupport.m
//  Add Folder Icons
//
//  Created by Andrew Hodgkinson on 03/02/2011.
//  Copyright 2011 Hipposoft. All rights reserved.
//

#import "ApplicationSupport.h"

@implementation ApplicationSupport

/******************************************************************************\
 * -applicationSupportDirectory
 *
 * Return the path to the Application Support subdirectory for the current user
 * identified by the name defined in 'APPLICATION_SUPPORT_DIRECTORY_FILENAME',
 * or the user's temporary directory if no application support directory can be
 * located.
 *
 * Out: ( NSString * )
 *      Full POSIX path of the support directory.
\******************************************************************************/

+ ( NSString * ) applicationSupportDirectory
{
    return
    [ self applicationSupportDirectoriesFor: APPLICATION_SUPPORT_DIRECTORY_FILENAME ][ 0 ];
}

/******************************************************************************\
 * -applicationSupportDirectoriesFor:
 *
 * Distantly derived from boilerplate Core Data material generated by Interface
 * Builder 3.2.5.
 *
 * Returns an array of support directories with the given leafname, based on
 * the user's domain only to ensure that the content can be both read from and
 * written to without requiring privilege escalation. If no appropriate
 * directory or directories can be located, the user's temporary directory is
 * returned instead and the given name is ignored.
 *
 * The user's support directory
 *
 * In:  ( NSString * ) name
 *      Name of the subdirectory of interest.
 *
 * Out: ( NSString * )
 *      Full POSIX path of the named Application Support subdirectory, or the
 *      user's temporary directory.
\******************************************************************************/

+ ( NSMutableArray * ) applicationSupportDirectoriesFor: ( NSString * ) name
{
    NSMutableArray * appPaths;
    NSArray        * supportPaths = NSSearchPathForDirectoriesInDomains
                                    (
                                        NSApplicationSupportDirectory,
                                        NSUserDomainMask,
                                        YES
                                    );

    if ( [ supportPaths count ] > 0 )
    {
        appPaths = [ NSMutableArray arrayWithCapacity: [ supportPaths count ] ];

        for ( NSString * path in supportPaths )
        {
            [ appPaths addObject: [ path stringByAppendingPathComponent: name ] ];
        }
    }
    else
    {
        appPaths = [ NSMutableArray arrayWithObject: NSTemporaryDirectory() ];
    }

    return appPaths;
}

/******************************************************************************\
 * -resourcePathFor:
 *
 * Return the full POSIX path to the resource of the given leaf name.
 *
 * In:  ( NSString * ) name
 *      Leaf name of resource of interest.
 *
 * Out: ( NSString * )
 *      Full POSIX path of the resource inside the application bundle.
\******************************************************************************/

+ ( NSString * ) resourcePathFor: ( NSString * ) name
{
    NSBundle * thisAppBundle = [ NSBundle mainBundle ];
    return [ thisAppBundle pathForResource: name ofType: nil ];
}

/******************************************************************************\
 * -auxiliaryExecutablePathFor:
 *
 * Return the full POSIX path to the auxiliary executable of the given leaf
 * name.
 *
 * In:  ( NSString * ) name
 *      Leaf name of auxiliary executable of interest.
 *
 * Out: ( NSString * )
 *      Full POSIX path of the auxiliary executable inside the application
 *      bundle.
\******************************************************************************/

+ ( NSString * ) auxiliaryExecutablePathFor: ( NSString * ) name
{
    NSBundle * thisAppBundle = [ NSBundle mainBundle ];
    return [ thisAppBundle pathForAuxiliaryExecutable: name ];
}

/******************************************************************************\
 * -copyItemToApplicationSupport:isExecutable:ifNewer:error:
 *
 * Copies a file identified by the given leafname (specified in full, including
 * a filename extension if necessary) from the application bundle to the
 * subdirectory in ~/Library/Application Support/... used for things like the
 * CoreData store.
 *
 * This method was historically created to export the command line tool from
 * the auxiliary executables folder inside the application bundle out into a
 * known shared location. However, that's unnecessary; other scripts can find
 * the tool by finding the application very easily. It also precluded the
 * possibility of having multiple versions of the application concurrently
 * installed and all referring, at least internally, to the correct revision
 * of the associated command line tool. Newer revisions of Add Folder Icons
 * just call their internal copy of the tool directly.
 *
 * To keep within general Mac OS guidelines, it's likely that this method
 * should not be called at all, except in very unusual circumstances. At the
 * time of writing I can't think of any, but I'm loathe to delete the code as
 * it was carefully constructed and works well. It may one day find a
 * legitimate use.
 *
 * In:  ( NSString * ) leafname
 *      Leafname of file to copy, including extension if necessary;
 *
 *      ( BOOL ) isExecutable
 *      If YES, the source file is assumed to be an auxiliary executable and
 *      the source path is set accordingly. If NO, the source file is assumed
 *      to be an application resource;
 *
 *      ( BOOL ) ifNewer
 *      If YES, the file is only copied if it hasn't been copied before, or if
 *      it is newer than a file of the same leafname already present in the
 *      subdirectory within "~/Library/Application Support". Any error from
 *      trying to determine this will lead to a copy being attempted. If NO,
 *      the file is copied regardless of whether or not the file is already
 *      present there and regardless of its modification date;
 *
 *      ( NSError ** ) error
 *      Passed through to NSFileManager's "-copyItemAtPath:toPath:error" as the
 *      'error' parameter. On exit, this is the only way that the caller can
 *      know if the copy succeeded; if you don't care either way, pass NULL.
 *
 * Out: ( BOOL )
 *      YES if an error occurred, else NO.
\******************************************************************************/

+ ( BOOL ) copyItemToApplicationSupport: ( NSString * ) leafname
                           isExecutable: ( BOOL       ) isExecutable
                                ifNewer: ( BOOL       ) ifNewer
                                  error: ( NSError ** ) error
{
    NSString      * sourcePathname;
    NSString      * targetFolder   = [ ApplicationSupport applicationSupportDirectory ];
    NSString      * targetPathname = [ targetFolder stringByAppendingPathComponent: leafname ];
    NSFileManager * fileManager    = [ [ NSFileManager alloc ] init ]; /* Result is thread safe; result of "+defaultManager" is not */

    if ( isExecutable ) sourcePathname = [ self auxiliaryExecutablePathFor: leafname ];
    else                sourcePathname = [ self resourcePathFor:            leafname ];

    if ( ifNewer == YES && [ fileManager fileExistsAtPath: targetPathname ] == YES )
    {
        NSDictionary * attributes;
        NSDate       * sourceDate;
        NSDate       * targetDate;
        NSError      * localError = nil;

        /* Not too worried about failures to read attributes at the target
         * path; we'll just let the code drop through and do the copy in
         * such a case and deal with errors that might arise then.
         */

        attributes = [ fileManager attributesOfItemAtPath: targetPathname error: &localError ];

        if ( localError == nil )
        {
            targetDate = [ attributes fileModificationDate ];
            attributes = [ fileManager attributesOfItemAtPath: sourcePathname error: &localError ];

            /* If there's an error reading attributes from the source file,
             * though, there could be a big problem. However, again, may as
             * well try and copy the file in such a case and let the copy
             * code deal with errors.
             */

            if ( localError == nil )
            {
                sourceDate = [ attributes fileModificationDate ];
                
                /* NSDate's "-compare:" returns the following:
                 *
                 * NSOrderedSame: Dates are identical.
                 * NSOrderedAscending: sourceDate is earlier than targetDate.
                 * NSOrderedDescending: sourcedate is later than targetDate.
                 *
                 * Thus, NSOrderedDescending tells us that the source file
                 * is newer than the target and we should copy again, else
                 * we should exit early.
                 */ 

                if ( [ sourceDate compare: targetDate ] != NSOrderedDescending ) 
                {
                    /* Early exit - no need to copy */

                    return NO;
                }
            }
        }
    }

    /* If we reach here, the file should be copied */

    [ fileManager removeItemAtPath: targetPathname error: NULL ];

    return [ fileManager copyItemAtPath: sourcePathname
                                 toPath: targetPathname
                                  error: error ];
}

@end
